/*
 * RTTY DEKÓDER - EGYSZERŰ IMPLEMENTÁCIÓ (TESZT)
 *
 * Használat: Cseréld le a DecoderRTTY-c1.cpp include-ot erre a fájlra!
 *
 * Architektúra:
 * - 2 fix Goertzel filter (MARK 1435 Hz, SPACE 985 Hz)
 * - 64-mintás sliding window
 * - Egyszer PLL bit recovery
 * - Baudot dekódolás
 */

#include "DecoderRTTY-c1.h"
#include "defines.h"
#include <cmath>
#include <cstring>

extern DecodedData decodedData;

// Konstansok - default értékek (config-ból felülíródnak)
#define DEFAULT_SAMPLE_RATE 7500.0f // NOTE: Overridden by config
#define DEFAULT_MARK_FREQ 2125.0f   // Default MARK frequency
#define DEFAULT_SPACE_FREQ 1675.0f  // Default SPACE frequency
#define DEFAULT_BAUD_RATE 45.45f    // Default baud rate

// Runtime configuration (a start()-ban inicializálódik a config-ból)
static float actualSampleRate = DEFAULT_SAMPLE_RATE;
static float actualMarkFreq = DEFAULT_MARK_FREQ;
static float actualSpaceFreq = DEFAULT_SPACE_FREQ;
static float actualBaudRate = DEFAULT_BAUD_RATE;
#define GOERTZEL_N 16           // Ablak méret - 16 mintás blokkok (gyorsabb PLL frissítés)
#define PLL_ALPHA 0.04f         // PLL loop gain (proportional) - slow stable tracking
#define PLL_BETA 0.002f         // PLL loop gain (integral) - slow stable tracking
#define PLL_LOCK_THRESHOLD 30   // Lock counter threshold
#define PLL_ENABLE_THRESHOLD 15 // Mikor engedélyezzük a loop filter-t

// Goertzel state
struct GoertzelState {
    float coeff;     // 2 * cos(2π * f / fs)
    float q1, q2;    // State variables
    float magnitude; // Result

    void init(float freq, float fs) {
        coeff = 2.0f * cosf(2.0f * PI * freq / fs);
        reset();
    }

    void reset() { q1 = q2 = magnitude = 0.0f; }

    void process(float sample) {
        float q0 = coeff * q1 - q2 + sample;
        q2 = q1;
        q1 = q0;
    }

    void computeMagnitude() { magnitude = sqrtf(q1 * q1 + q2 * q2 - q1 * q2 * coeff); }
};

// Globális state
static GoertzelState markFilter, spaceFilter;
static float sampleBuffer[GOERTZEL_N];
static int bufferIndex = 0;
static int samplesProcessed = 0;

// PLL state
static float pllPhase = 0.0f;
static float pllFreq = 0.0f; // Initialized in start()
static bool lastTone = true; // true = MARK, false = SPACE
static bool pllLocked = false;
static int lockCounter = 0;

// Baudot state
static uint8_t shiftState = 0; // 0 = LTRS, 1 = FIGS
static int bitCounter = 0;
static uint8_t receivedByte = 0;
static enum { WAIT_START, RECEIVE_DATA, RECEIVE_STOP } rttyState = WAIT_START;

// Baudot tables
static const char LTRS[32] = {0,   'E', '\n', 'A', ' ', 'S', 'I', 'U', '\r', 'D', 'R', 'J', 'N', 'F', 'C', 'K',
                              'T', 'Z', 'L',  'W', 'H', 'Y', 'P', 'Q', 'O',  'B', 'G', 0,   'M', 'X', 'V', 0};

static const char FIGS[32] = {0,   '3', '\n', '-', ' ', '\'', '8', '7', '\r', '$', '4', '\a', ',', '!', ':', '(',
                              '5', '+', ')',  '2', '#', '6',  '0', '1', '9',  '?', '&', 0,    '.', '/', ';', 0};

// Baudot dekódolás
static void decodeBaudot(uint8_t code) {
    if (code == 0x1F) { // LTRS
        shiftState = 0;
        return;
    }
    if (code == 0x1B) { // FIGS
        shiftState = 1;
        return;
    }

    char ch = (shiftState == 0) ? LTRS[code & 0x1F] : FIGS[code & 0x1F];
    if (ch != 0) {
        decodedData.textBuffer.put(ch);
        DEBUG("RTTY: '%c' (0x%02X)\n", ch, code);
    }
}

// PLL + bit processing (BLOKKOSAN - GOERTZEL_N mintát reprezentál)
static void processTone(bool isMark) {
    // Edge detection
    bool edge = (isMark != lastTone);
    lastTone = isMark;

    if (edge) {
        // Phase error
        float error = (pllPhase < 0.5f) ? pllPhase : (pllPhase - 1.0f);

        lockCounter++;

        // Loop filter minden edge-nél (normál PLL működés)
        if (lockCounter > PLL_ENABLE_THRESHOLD) {
            pllFreq += PLL_BETA * error;
            pllPhase += PLL_ALPHA * error;

            // Clamp pllFreq to ±5% of nominal
            float nominalFreq = actualBaudRate / actualSampleRate;
            float minFreq = nominalFreq * 0.95f;
            float maxFreq = nominalFreq * 1.05f;
            if (pllFreq < minFreq)
                pllFreq = minFreq;
            if (pllFreq > maxFreq)
                pllFreq = maxFreq;
        }

        if (lockCounter > PLL_LOCK_THRESHOLD && !pllLocked) {
            pllLocked = true;
            DEBUG("RTTY: PLL locked (after %d edges), pllFreq=%.6f\n", lockCounter, pllFreq);
        }
    } // Phase increment for GOERTZEL_N samples
    // (szimuláljuk a 64 minta phase előrehaladását)
    for (int step = 0; step < GOERTZEL_N; step++) {
        pllPhase += pllFreq;

        // Bit sampling
        if (pllPhase >= 1.0f) {
            pllPhase -= 1.0f;

            bool bit = isMark;

            // Debug: bit sampling occurred
            static int bitSampleCnt = 0;
            if (++bitSampleCnt >= 5) {
                DEBUG("RTTY: Bit sampled: %s (locked=%d, state=%d)\n", bit ? "MARK" : "SPACE", pllLocked ? 1 : 0, (int)rttyState);
                bitSampleCnt = 0;
            }

            // CSAK PLL lock után dekódoljunk!
            if (!pllLocked) {
                continue; // Skip bit processing if not locked yet
            }

            // Baudot state machine
            switch (rttyState) {
                case WAIT_START:
                    if (!bit) { // Start bit = SPACE
                        rttyState = RECEIVE_DATA;
                        bitCounter = 0; // Vissza 0-ra - nincs delay
                        receivedByte = 0;
                        // NEM korrigálunk a phase-en! Hagyjuk a PLL-t szabadon futni
                        DEBUG("RTTY: Start bit detected\n");
                    }
                    break;

                case RECEIVE_DATA:
                    receivedByte |= (bit ? 1 : 0) << bitCounter;
                    bitCounter++;
                    if (bitCounter >= 5) {
                        rttyState = RECEIVE_STOP;
                    }
                    break;

                case RECEIVE_STOP:
                    // Dekódoljuk akkor is, ha a stop bit nem tökéletes
                    // (zajos jeleknél ez javítja a decode rate-et)
                    decodeBaudot(receivedByte);
                    if (!bit) {
                        // DEBUG("RTTY: Framing error\n"); // Commented out - too verbose
                    }
                    rttyState = WAIT_START;
                    break;
            }
        }
    }
} // Tone detection
static void detectAndProcess() {
    markFilter.computeMagnitude();
    spaceFilter.computeMagnitude();

    float markMag = markFilter.magnitude;
    float spaceMag = spaceFilter.magnitude;

    // Decision with hysteresis and minimum SNR
    static bool lastDecision = true; // true = MARK
    bool isMark;

    float totalMag = markMag + spaceMag;
    if (totalMag < 100.0f) {
        // Too weak signal, keep last decision
        isMark = lastDecision;
    } else {
        // Calculate ratio (normalized)
        float markRatio = markMag / totalMag;

        // Hysteresis: 0.45-0.55 dead zone
        if (markRatio > 0.55f) {
            isMark = true;
        } else if (markRatio < 0.45f) {
            isMark = false;
        } else {
            // In dead zone, keep previous decision
            isMark = lastDecision;
        }
    }

    lastDecision = isMark;

    // Debug (minden 100. minta)
    static int dbgCnt = 0;
    if (++dbgCnt >= 100) {
        float ratio = (markMag + spaceMag > 0) ? (markMag / (markMag + spaceMag)) : 0.5f;
        DEBUG("RTTY: M=%.0f, S=%.0f, ratio=%.2f, %s\n", markMag, spaceMag, ratio, isMark ? "MARK" : "SPACE");
        dbgCnt = 0;
    }

    processTone(isMark);
}

// ===== PUBLIC API =====

DecoderRTTY_C1::DecoderRTTY_C1() {}
DecoderRTTY_C1::~DecoderRTTY_C1() {}

bool DecoderRTTY_C1::start(const DecoderConfig &config) {
    // Get runtime config values
    actualSampleRate = (float)config.samplingRate;
    actualMarkFreq = (float)config.rttyMarkFreqHz;
    actualSpaceFreq = actualMarkFreq - (float)config.rttyShiftFreqHz;
    actualBaudRate = config.rttyBaud;

    // Init Goertzel with actual frequencies
    markFilter.init(actualMarkFreq, actualSampleRate);
    spaceFilter.init(actualSpaceFreq, actualSampleRate);

    // Reset state
    bufferIndex = 0;
    samplesProcessed = 0;
    pllPhase = 0.0f;
    pllFreq = actualBaudRate / actualSampleRate;
    pllLocked = false;
    lockCounter = 0;
    rttyState = WAIT_START;
    shiftState = 0;

    memset(sampleBuffer, 0, sizeof(sampleBuffer));

    decodedData.rttyMarkFreq = (uint16_t)actualMarkFreq;
    decodedData.rttySpaceFreq = (uint16_t)actualSpaceFreq;
    decodedData.rttyBaudRate = actualBaudRate;

    DEBUG("RTTY: Started - Mark=%.0f Hz, Space=%.0f Hz, Baud=%.2f, SampleRate=%.0f Hz\n", actualMarkFreq, actualSpaceFreq, actualBaudRate, actualSampleRate);
    return true;
}

void DecoderRTTY_C1::stop() { DEBUG("RTTY: Stopped\n"); }

void DecoderRTTY_C1::processSamples(const int16_t *samples, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        float sample = (float)samples[i];

        // Accumulate sample
        sampleBuffer[bufferIndex] = sample;
        bufferIndex++;

        // When buffer full: process block
        if (bufferIndex >= GOERTZEL_N) {
            // Process Goertzel on full block
            markFilter.reset();
            spaceFilter.reset();

            for (int j = 0; j < GOERTZEL_N; j++) {
                markFilter.process(sampleBuffer[j]);
                spaceFilter.process(sampleBuffer[j]);
            }

            // Detect tone and update PLL
            detectAndProcess();

            // Reset buffer
            bufferIndex = 0;
        }
    }
} // Dummy implementations (removed - implemented in header inline)
void DecoderRTTY_C1::resetDecoder() {}
void DecoderRTTY_C1::initializeToneDetector() {}
void DecoderRTTY_C1::configureToneBins(float, std::array<GoertzelBin, BINS_PER_TONE> &) {}
void DecoderRTTY_C1::resetGoertzelState() {}
void DecoderRTTY_C1::processToneBlock(const int16_t *, size_t) {}
bool DecoderRTTY_C1::detectTone(bool &, float &) { return false; }
void DecoderRTTY_C1::initializePLL() {}
void DecoderRTTY_C1::updatePLL(bool, bool &, bool &) {}
void DecoderRTTY_C1::processBit(bool) {}
char DecoderRTTY_C1::decodeBaudotCharacter(uint8_t) { return 0; }

const char DecoderRTTY_C1::BAUDOT_LTRS_TABLE[32] = {};
const char DecoderRTTY_C1::BAUDOT_FIGS_TABLE[32] = {};
